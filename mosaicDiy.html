<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂõæÁâáÈ©¨ËµõÂÖãÂ§ÑÁêÜÂô®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .upload-btn {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }

        .slider {
            width: 180px;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            margin-bottom: 10px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .value-display {
            font-size: 1.1em;
            color: #667eea;
            font-weight: bold;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 30px 0;
            position: relative;
            gap: 20px;
        }

        .canvas-wrapper {
            position: relative;
            border: 3px solid #667eea;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-height: 600px;
            overflow: auto;
        }

        #canvas,
        #maskCanvas {
            display: block;
            transition: transform 0.2s ease;
        }

        #maskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.6;
            mix-blend-mode: multiply;
        }

        .drawing-mode #maskCanvas {
            pointer-events: auto;
            cursor: none;
        }

        .brush-cursor {
            position: fixed;
            border: 2px solid #667eea;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            background: rgba(102, 126, 234, 0.2);
            transform: translate(-50%, -50%);
            display: none;
            transition: all 0.1s ease;
        }

        .zoom-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .zoom-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .zoom-info {
            font-size: 0.9em;
            color: #667eea;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
        }

        .status {
            padding: 10px 20px;
            border-radius: 25px;
            margin: 10px 0;
            font-weight: bold;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status.error {
            background: rgba(244, 67, 54, 0.1);
            color: #F44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .status.info {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .dragging {
            cursor: grab !important;
        }

        .dragging:active {
            cursor: grabbing !important;
        }

        .image-info {
            text-align: center;
            color: #667eea;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .save-options {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .quality-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .performance-info {
            text-align: center;
            color: #667eea;
            font-size: 0.85em;
            margin-top: 5px;
            opacity: 0.8;
        }

        .preview-mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            display: none;
        }

        .format-selector select {
            padding: 8px 12px;
            border-radius: 15px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .format-selector select:hover {
            border-color: #764ba2;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .format-selector select:focus {
            outline: none;
            border-color: #764ba2;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .preview-active .preview-mode-indicator {
            display: block;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }

            .action-buttons {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 200px;
            }

            .canvas-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üé® ÂõæÁâáÈ©¨ËµõÂÖãÂ§ÑÁêÜÂô®</h1>
            <p>‰∏ä‰º†ÂõæÁâáÔºåÊ∂ÇÊäπÂå∫ÂüüÔºåÂÆûÊó∂È¢ÑËßàÈ©¨ËµõÂÖãÊïàÊûú</p>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('imageInput').click()">
                    üìÅ ÈÄâÊã©ÂõæÁâá
                </button>
                <div id="status" class="status info" style="display: none;">ËØ∑ÈÄâÊã©‰∏ÄÂº†ÂõæÁâáÂºÄÂßãÂ§ÑÁêÜ</div>
                <div id="imageInfo" class="image-info" style="display: none;"></div>
                <div id="performanceInfo" class="performance-info" style="display: none;"></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="brushSize">ÁîªÁ¨îÂ§ßÂ∞è</label>
                    <input type="range" id="brushSize" class="slider" min="1" max="50" value="20">
                    <span class="value-display" id="brushSizeValue">20px</span>
                </div>

                <div class="control-group">
                    <label for="pathSmoothness">Ë∑ØÂæÑÂπ≥ÊªëÂ∫¶</label>
                    <input type="range" id="pathSmoothness" class="slider" min="1" max="10" value="3">
                    <span class="value-display" id="pathSmoothnessValue">‰∏≠Á≠â</span>
                </div>

                <div class="control-group">
                    <label for="mosaicSize">È©¨ËµõÂÖãÁ≤æÁªÜÂ∫¶</label>
                    <input type="range" id="mosaicSize" class="slider" min="1" max="50" value="5">
                    <span class="value-display" id="mosaicSizeValue">5px</span>
                </div>

                <div class="control-group">
                    <label for="quality">‰øùÂ≠òË¥®Èáè</label>
                    <input type="range" id="quality" class="slider" min="50" max="100" value="95">
                    <span class="value-display" id="qualityValue">95%</span>
                </div>

                <div class="action-buttons">
                    <div class="save-options">
                        <button class="btn" id="drawBtn" disabled>üñåÔ∏è Ê∂ÇÊäπÊ®°Âºè</button>
                        <button class="btn" id="applyBtn" disabled>‚ú® Â∫îÁî®È©¨ËµõÂÖã</button>
                        <button class="btn" id="clearBtn" disabled>üóëÔ∏è Ê∏ÖÈô§Ê∂ÇÊäπ</button>

                        <!-- Âú®ËøôÈáåÊ∑ªÂä†Ê†ºÂºèÈÄâÊã©Âô® -->
                        <div class="format-selector" style="display: flex; align-items: center; gap: 10px;">
                            <label for="outputFormat" style="color: #667eea; font-weight: bold;">‰øùÂ≠òÊ†ºÂºè:</label>
                            <select id="outputFormat"
                                style="padding: 8px; border-radius: 15px; border: 2px solid #667eea; background: white; color: #667eea; font-weight: bold;">
                                <option value="png">PNG (Êó†Êçü)</option>
                                <option value="jpg">JPG (ÂéãÁº©)</option>
                                <option value="webp">WebP (È´òÊïà)</option>
                            </select>
                        </div>

                        <button class="btn" id="saveBtn" disabled>üíæ ‰øùÂ≠òÁºñËæëÂêéÁöÑÂõæÁâá</button>
                        <button class="btn" id="saveOriginalBtn" disabled>üì• ‰øùÂ≠òÂéüÂõæ</button>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="canvas"></canvas>
                    <canvas id="maskCanvas"></canvas>
                    <div class="brush-cursor" id="brushCursor"></div>
                    <div class="preview-mode-indicator">È¢ÑËßàÊ®°Âºè</div>
                </div>

                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomInBtn" disabled title="ÊîæÂ§ß">+</button>
                    <button class="zoom-btn" id="zoomOutBtn" disabled title="Áº©Â∞è">-</button>
                    <button class="zoom-btn" id="zoomResetBtn" disabled title="ÈáçÁΩÆÁº©Êîæ">‚Üª</button>
                    <div class="zoom-info" id="zoomInfo">100%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class MosaicEditor {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.maskCanvas = document.getElementById('maskCanvas');
                this.maskCtx = this.maskCanvas.getContext('2d');
                this.canvasWrapper = document.getElementById('canvasWrapper');
                this.brushCursor = document.getElementById('brushCursor');

                // ÂéüÂßãÂõæÁâáÊï∞ÊçÆÂíåÂ∞∫ÂØ∏
                this.originalImage = null;
                this.originalFile = null;
                this.originalWidth = 0;
                this.originalHeight = 0;
                this.originalImageData = null;
                this.currentImageData = null;
                this.hasEdits = false;

                // ÊòæÁ§∫Â∞∫ÂØ∏ÂíåÁº©Êîæ
                this.displayWidth = 0;
                this.displayHeight = 0;
                this.displayScale = 1;
                this.maxDisplaySize = 800; // ÊúÄÂ§ßÊòæÁ§∫Â∞∫ÂØ∏

                // È¢ÑËßàÊ®°ÂºèÁõ∏ÂÖ≥
                this.isPreviewMode = false;
                this.previewImageData = null;

                // ÊÄßËÉΩ‰ºòÂåñÁõ∏ÂÖ≥
                this.maskCache = new Map(); // ÁºìÂ≠òÂ∑≤Â§ÑÁêÜÁöÑÈ©¨ËµõÂÖãÂùó
                this.throttleTimer = null;
                this.batchProcessing = false;
                this.pendingRegions = [];

                // ÂàÜÁ¶ªÁúüÂÆûÈÅÆÁΩ©Êï∞ÊçÆÂíåÂèØËßÜÂåñ
                this.maskRegions = []; // Â≠òÂÇ®ÁúüÂÆûÁöÑÈÅÆÁΩ©Âå∫ÂüüÊï∞ÊçÆ
                this.realMaskCanvas = document.createElement('canvas'); // ÁúüÂÆûÁöÑÈÅÆÁΩ©Êï∞ÊçÆ
                this.realMaskCtx = this.realMaskCanvas.getContext('2d');

                this.isDrawing = false;
                this.drawingMode = false;

                // Ë∑ØÂæÑÂπ≥ÊªëÁõ∏ÂÖ≥
                this.lastDrawPoint = null; // ‰∏ä‰∏Ä‰∏™ÁªòÂà∂ÁÇπ
                this.pathSmoothness = 3; // Ë∑ØÂæÑÂπ≥ÊªëÂ∫¶

                this.brushSize = 20;
                this.mosaicSize = 5;
                this.quality = 95;
                this.zoomLevel = 1;
                this.maxZoom = 3;
                this.minZoom = 0.25;

                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.scrollLeft = 0;
                this.scrollTop = 0;

                this.originalFileName = '';
                this.originalFileExtension = '';

                this.initEventListeners();
                this.updateBrushCursor();
                this.updateZoomDisplay();
            }

            initEventListeners() {
                // Êñá‰ª∂‰∏ä‰º†
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });

                // ÊéßÂà∂ÊªëÂùó
                const brushSizeSlider = document.getElementById('brushSize');
                const pathSmoothnessSlider = document.getElementById('pathSmoothness');
                const mosaicSizeSlider = document.getElementById('mosaicSize');
                const qualitySlider = document.getElementById('quality');

                brushSizeSlider.addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeValue').textContent = this.brushSize + 'px';
                    this.updateBrushCursor();
                });

                pathSmoothnessSlider.addEventListener('input', (e) => {
                    this.pathSmoothness = parseInt(e.target.value);
                    const smoothnessTexts = ['ÊúÄ‰Ωé', 'Âæà‰Ωé', 'ËæÉ‰Ωé', '‰∏≠Á≠â', 'ËæÉÈ´ò', 'ÂæàÈ´ò', 'ÊúÄÈ´ò', 'Ë∂ÖÈ´ò', 'ÊûÅÈ´ò', 'ÂÆåÁæé'];
                    document.getElementById('pathSmoothnessValue').textContent = smoothnessTexts[this.pathSmoothness - 1];
                });

                mosaicSizeSlider.addEventListener('input', (e) => {
                    this.mosaicSize = parseInt(e.target.value);
                    document.getElementById('mosaicSizeValue').textContent = this.mosaicSize + 'px';
                    // Ê∏ÖÈô§ÁºìÂ≠òÔºåÂõ†‰∏∫È©¨ËµõÂÖãÂ§ßÂ∞èÊîπÂèò‰∫Ü
                    this.maskCache.clear();
                    // Â¶ÇÊûúÂú®È¢ÑËßàÊ®°ÂºèÔºåÁ´ãÂç≥Êõ¥Êñ∞È¢ÑËßà
                    if (this.isPreviewMode) {
                        this.updatePreview();
                    }
                });

                qualitySlider.addEventListener('input', (e) => {
                    this.quality = parseInt(e.target.value);
                    document.getElementById('qualityValue').textContent = this.quality + '%';
                });

                // ÊåâÈíÆ‰∫ã‰ª∂ - ‰øÆÂ§çËøôÈáåÁöÑ‰∫ã‰ª∂ÁªëÂÆö
                document.getElementById('drawBtn').addEventListener('click', () => this.toggleDrawingMode());
                document.getElementById('applyBtn').addEventListener('click', () => this.handleApplyButton());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearMask());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveImage());
                document.getElementById('saveOriginalBtn').addEventListener('click', () => this.saveOriginalImage());

                // Áº©ÊîæÊåâÈíÆ
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomResetBtn').addEventListener('click', () => this.resetZoom());

                // ÁîªÂ∏ÉÁªòÂà∂‰∫ã‰ª∂
                this.maskCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.maskCanvas.addEventListener('mousemove', (e) => this.draw(e));
                this.maskCanvas.addEventListener('mouseup', () => this.stopDrawing());
                this.maskCanvas.addEventListener('mouseout', () => this.stopDrawing());
                this.maskCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Èº†Ê†áÁßªÂä®‰∫ã‰ª∂
                this.maskCanvas.addEventListener('mousemove', (e) => this.updateCursorPosition(e));
                this.maskCanvas.addEventListener('mouseenter', () => this.showBrushCursor());
                this.maskCanvas.addEventListener('mouseleave', () => this.hideBrushCursor());

                // Èº†Ê†áÊªöËΩÆÁº©Êîæ
                this.canvasWrapper.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (e.deltaY < 0) {
                        this.zoomIn();
                    } else {
                        this.zoomOut();
                    }
                });

                // Ëß¶Êë∏‰∫ã‰ª∂ÊîØÊåÅ
                this.maskCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                    this.maskCanvas.dispatchEvent(mouseEvent);
                });

                this.maskCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.maskCanvas.dispatchEvent(mouseEvent);
                });

                this.maskCanvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const mouseEvent = new MouseEvent('mouseup', {});
                    this.maskCanvas.dispatchEvent(mouseEvent);
                });

                // Èº†Ê†á‰∏≠ÈîÆÊãñÊãΩ‰∫ã‰ª∂
                this.canvasWrapper.addEventListener('mousedown', (e) => {
                    if (e.button === 1) {
                        e.preventDefault();
                        this.startDragging(e);
                    }
                });

                this.canvasWrapper.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        e.preventDefault();
                        this.drag(e);
                    }
                });

                this.canvasWrapper.addEventListener('mouseup', (e) => {
                    if (e.button === 1) {
                        this.stopDragging();
                    }
                });

                this.canvasWrapper.addEventListener('mouseleave', () => {
                    this.stopDragging();
                });
            }

            // Êñ∞Â¢ûÔºöÁªü‰∏ÄÂ§ÑÁêÜÂ∫îÁî®ÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
            handleApplyButton() {
                if (this.isPreviewMode) {
                    this.exitPreview();
                } else {
                    this.applyMosaic();
                }
            }

            startDragging(e) {
                this.isDragging = true;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                this.scrollLeft = this.canvasWrapper.scrollLeft;
                this.scrollTop = this.canvasWrapper.scrollTop;
                this.canvasWrapper.classList.add('dragging');
            }

            drag(e) {
                if (!this.isDragging) return;

                const dx = e.clientX - this.dragStartX;
                const dy = e.clientY - this.dragStartY;

                this.canvasWrapper.scrollLeft = this.scrollLeft - dx;
                this.canvasWrapper.scrollTop = this.scrollTop - dy;
            }

            stopDragging() {
                this.isDragging = false;
                this.canvasWrapper.classList.remove('dragging');
            }

            showStatus(message, type = 'info') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
                statusEl.style.display = 'block';
            }

            // ËÆ°ÁÆóÂêàÈÄÇÁöÑÊòæÁ§∫Â∞∫ÂØ∏
            calculateDisplaySize(originalWidth, originalHeight) {
                if (originalWidth <= this.maxDisplaySize && originalHeight <= this.maxDisplaySize) {
                    return {
                        width: originalWidth,
                        height: originalHeight,
                        scale: 1
                    };
                }

                const aspectRatio = originalWidth / originalHeight;
                let displayWidth, displayHeight;

                if (originalWidth > originalHeight) {
                    displayWidth = this.maxDisplaySize;
                    displayHeight = Math.round(this.maxDisplaySize / aspectRatio);
                } else {
                    displayHeight = this.maxDisplaySize;
                    displayWidth = Math.round(this.maxDisplaySize * aspectRatio);
                }

                return {
                    width: displayWidth,
                    height: displayHeight,
                    scale: displayWidth / originalWidth
                };
            }

            loadImage(file) {
                if (!file) return;

                this.originalFile = file;
                this.hasEdits = false;
                this.isPreviewMode = false;
                this.maskCache.clear();
                this.canvasWrapper.classList.remove('preview-active');

                this.originalFileName = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;
                this.originalFileExtension = file.name.substring(file.name.lastIndexOf('.')) || '.png';

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.originalWidth = img.width;
                        this.originalHeight = img.height;

                        // ËÆ°ÁÆóÊòæÁ§∫Â∞∫ÂØ∏
                        const displaySize = this.calculateDisplaySize(this.originalWidth, this.originalHeight);
                        this.displayWidth = displaySize.width;
                        this.displayHeight = displaySize.height;
                        this.displayScale = displaySize.scale;

                        // ËÆæÁΩÆÁîªÂ∏É‰∏∫ÊòæÁ§∫Â∞∫ÂØ∏
                        this.canvas.width = this.displayWidth;
                        this.canvas.height = this.displayHeight;
                        this.maskCanvas.width = this.displayWidth;
                        this.maskCanvas.height = this.displayHeight;

                        // ËÆæÁΩÆÁúüÂÆûÈÅÆÁΩ©ÁîªÂ∏É‰∏∫ÊòæÁ§∫Â∞∫ÂØ∏
                        this.realMaskCanvas.width = this.displayWidth;
                        this.realMaskCanvas.height = this.displayHeight;

                        // ÁªòÂà∂Áº©ÊîæÂêéÁöÑÂõæÁâáÂà∞ÊòæÁ§∫ÁîªÂ∏É
                        this.ctx.drawImage(img, 0, 0, this.displayWidth, this.displayHeight);

                        // ‰øùÂ≠òÂéüÂßãÂõæÁâáÊï∞ÊçÆÔºàÂéüÂßãÂ∞∫ÂØ∏Ôºâ
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = this.originalWidth;
                        tempCanvas.height = this.originalHeight;
                        tempCtx.drawImage(img, 0, 0, this.originalWidth, this.originalHeight);
                        this.originalImageData = tempCtx.getImageData(0, 0, this.originalWidth, this.originalHeight);

                        // ‰øùÂ≠òÂΩìÂâçÊòæÁ§∫ÁöÑÂõæÁâáÊï∞ÊçÆ
                        this.currentImageData = this.ctx.getImageData(0, 0, this.displayWidth, this.displayHeight);

                        // Ê∏ÖÈô§ÈÅÆÁΩ©ÂíåÈÅÆÁΩ©Âå∫ÂüüËÆ∞ÂΩï
                        this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                        this.realMaskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                        this.maskRegions = [];

                        // ÈáçÁΩÆË∑ØÂæÑË∑üË∏™
                        this.lastDrawPoint = null;

                        this.zoomLevel = 1;
                        this.updateZoom();
                        this.enableButtons();
                        this.showImageInfo();

                        // ÈáçÁΩÆÊåâÈíÆÁä∂ÊÄÅ
                        this.resetApplyButtonState();

                        const isScaled = this.displayScale < 1;
                        const scaleInfo = isScaled ? `ÔºåÂ∑≤Áº©ÊîæËá≥ ${Math.round(this.displayScale * 100)}% ÊòæÁ§∫` : '';
                        this.showStatus(`ÂõæÁâáÂä†ËΩΩÊàêÂäüÔºÅ${scaleInfo}Êú™ÁºñËæëÊó∂Âª∫ËÆÆ‰ΩøÁî®"‰øùÂ≠òÂéüÂõæ"ÈÅøÂÖçË¥®ÈáèÊçüÂ§±`, 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            showImageInfo() {
                const infoEl = document.getElementById('imageInfo');
                const fileSizeKB = Math.round(this.originalFile.size / 1024);
                infoEl.textContent = `ÂéüÂßãÂàÜËæ®Áéá: ${this.originalWidth} √ó ${this.originalHeight}, Êñá‰ª∂Â§ßÂ∞è: ${fileSizeKB}KB`;
                infoEl.style.display = 'block';

                const performanceInfoEl = document.getElementById('performanceInfo');
                if (this.displayScale < 1) {
                    performanceInfoEl.textContent = `ÁºñËæëÂàÜËæ®Áéá: ${this.displayWidth} √ó ${this.displayHeight} (${Math.round(this.displayScale * 100)}% Áº©ÊîæÔºå‰ºòÂåñÊÄßËÉΩ)`;
                    performanceInfoEl.style.display = 'block';
                } else {
                    performanceInfoEl.style.display = 'none';
                }
            }

            enableButtons() {
                ['drawBtn', 'clearBtn', 'saveBtn', 'saveOriginalBtn', 'zoomInBtn', 'zoomOutBtn', 'zoomResetBtn'].forEach(id => {
                    document.getElementById(id).disabled = false;
                });
            }

            // Êñ∞Â¢ûÔºöÈáçÁΩÆÂ∫îÁî®ÊåâÈíÆÁä∂ÊÄÅ
            resetApplyButtonState() {
                const applyBtn = document.getElementById('applyBtn');
                applyBtn.textContent = '‚ú® Â∫îÁî®È©¨ËµõÂÖã';
                applyBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }

            zoomIn() {
                if (this.zoomLevel < this.maxZoom) {
                    this.zoomLevel = Math.min(this.maxZoom, this.zoomLevel + 0.25);
                    this.updateZoom();
                }
            }

            zoomOut() {
                if (this.zoomLevel > this.minZoom) {
                    this.zoomLevel = Math.max(this.minZoom, this.zoomLevel - 0.25);
                    this.updateZoom();
                }
            }

            resetZoom() {
                this.zoomLevel = 1;
                this.updateZoom();
            }

            updateZoom() {
                this.canvas.style.transform = `scale(${this.zoomLevel})`;
                this.maskCanvas.style.transform = `scale(${this.zoomLevel})`;
                this.updateZoomDisplay();
                this.updateBrushCursor();
            }

            updateZoomDisplay() {
                document.getElementById('zoomInfo').textContent = Math.round(this.zoomLevel * 100) + '%';
                document.getElementById('zoomInBtn').disabled = this.zoomLevel >= this.maxZoom;
                document.getElementById('zoomOutBtn').disabled = this.zoomLevel <= this.minZoom;
            }

            toggleDrawingMode() {
                this.drawingMode = !this.drawingMode;
                const btn = document.getElementById('drawBtn');

                if (this.drawingMode) {
                    btn.textContent = 'üõë ÈÄÄÂá∫Ê∂ÇÊäπ';
                    btn.style.background = 'linear-gradient(135deg, #f44336 0%, #d32f2f 100%)';
                    document.querySelector('.canvas-wrapper').classList.add('drawing-mode');
                    this.showStatus('Ê∂ÇÊäπÊ®°ÂºèÂ∑≤ÂºÄÂêØÔºåÁÅ∞Ëâ≤Âå∫ÂüüË°®Á§∫Â∑≤Ê∂ÇÊäπËåÉÂõ¥', 'info');
                    document.getElementById('applyBtn').disabled = false;
                } else {
                    btn.textContent = 'üñåÔ∏è Ê∂ÇÊäπÊ®°Âºè';
                    btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    document.querySelector('.canvas-wrapper').classList.remove('drawing-mode');
                    this.hideBrushCursor();
                    this.showStatus('Ê∂ÇÊäπÊ®°ÂºèÂ∑≤ÂÖ≥Èó≠', 'info');
                }

                // ÈáçÁΩÆË∑ØÂæÑË∑üË∏™
                this.lastDrawPoint = null;
            }

            updateBrushCursor() {
                const scaledSize = this.brushSize * this.zoomLevel;
                this.brushCursor.style.width = scaledSize + 'px';
                this.brushCursor.style.height = scaledSize + 'px';
            }

            updateCursorPosition(e) {
                if (!this.drawingMode) return;
                this.brushCursor.style.left = e.clientX + 'px';
                this.brushCursor.style.top = e.clientY + 'px';
            }

            showBrushCursor() {
                if (this.drawingMode) {
                    this.brushCursor.style.display = 'block';
                }
            }

            hideBrushCursor() {
                this.brushCursor.style.display = 'none';
            }

            getMousePos(e) {
                const rect = this.maskCanvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            startDrawing(e) {
                if (!this.drawingMode) return;
                if (e.button !== 0) return;

                this.isDrawing = true;
                this.hasEdits = true;

                const pos = this.getMousePos(e);
                this.lastDrawPoint = pos;

                this.drawAtPosition(pos);
            }

            draw(e) {
                if (!this.isDrawing || !this.drawingMode) return;

                const currentPos = this.getMousePos(e);
                this.updateCursorPosition(e);

                if (this.lastDrawPoint) {
                    // ‰ΩøÁî®Ë∑ØÂæÑÂπ≥ÊªëÂ∫¶Êù•ÊèíÂÄºÁªòÂà∂
                    this.drawSmoothPath(this.lastDrawPoint, currentPos);
                } else {
                    this.drawAtPosition(currentPos);
                }

                this.lastDrawPoint = currentPos;
            }

            // Êñ∞Â¢ûÔºöÂπ≥ÊªëË∑ØÂæÑÁªòÂà∂ÊñπÊ≥ï
            drawSmoothPath(startPos, endPos) {
                const distance = Math.sqrt(
                    Math.pow(endPos.x - startPos.x, 2) +
                    Math.pow(endPos.y - startPos.y, 2)
                );

                // Ê†πÊçÆË∑ØÂæÑÂπ≥ÊªëÂ∫¶ÂíåÁîªÁ¨îÂ§ßÂ∞èËÆ°ÁÆóÊèíÂÄºÁÇπÊï∞Èáè
                // Âπ≥ÊªëÂ∫¶Ë∂äÈ´òÔºåÊèíÂÄºÁÇπË∂äÂ§öÔºåË∑ØÂæÑË∂äËøûÁª≠
                const brushRadius = this.brushSize / 2;
                const maxStepSize = brushRadius / this.pathSmoothness;
                const steps = Math.max(1, Math.ceil(distance / maxStepSize));

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const interpolatedPos = {
                        x: startPos.x + (endPos.x - startPos.x) * t,
                        y: startPos.y + (endPos.y - startPos.y) * t
                    };

                    this.drawAtPosition(interpolatedPos);
                }
            }

            // Êñ∞Â¢ûÔºöÂú®ÊåáÂÆö‰ΩçÁΩÆÁªòÂà∂
            drawAtPosition(pos) {
                // ËÆ∞ÂΩïÈÅÆÁΩ©Âå∫ÂüüÁî®‰∫éÁîüÊàêÊúÄÁªàÈ©¨ËµõÂÖã
                this.maskRegions.push({
                    x: pos.x,
                    y: pos.y,
                    radius: this.brushSize / 2
                });

                // Âú®ÁúüÂÆûÈÅÆÁΩ©ÁîªÂ∏É‰∏äÁªòÂà∂ÔºàÁôΩËâ≤ÔºåÁî®‰∫éÂêéÁª≠È©¨ËµõÂÖãÂ§ÑÁêÜÔºâ
                this.realMaskCtx.globalCompositeOperation = 'source-over';
                this.realMaskCtx.fillStyle = 'white';
                this.realMaskCtx.beginPath();
                this.realMaskCtx.arc(pos.x, pos.y, this.brushSize / 2, 0, 2 * Math.PI);
                this.realMaskCtx.fill();

                // Âú®ÂèØËßÜÂåñÈÅÆÁΩ©Â±ÇÁªòÂà∂ÂèØËßÜÂåñÊèêÁ§∫
                this.updateMaskVisualization();

                // Â¶ÇÊûúÂú®È¢ÑËßàÊ®°ÂºèÔºåÂÆûÊó∂Êõ¥Êñ∞È©¨ËµõÂÖãÊïàÊûú
                if (this.isPreviewMode) {
                    // ËäÇÊµÅÂ§ÑÁêÜÔºåÈÅøÂÖçÈ¢ëÁπÅËÆ°ÁÆóÈ©¨ËµõÂÖã
                    if (this.throttleTimer) {
                        clearTimeout(this.throttleTimer);
                    }

                    this.throttleTimer = setTimeout(() => {
                        this.updatePreviewAtPosition(pos.x, pos.y, this.brushSize / 2);
                    }, 16); // Á∫¶60fps
                }
            }

            updateMaskVisualization() {
                if (this.isPreviewMode) {
                    // È¢ÑËßàÊ®°Âºè‰∏ã‰∏çÊòæÁ§∫ÁÅ∞Ëâ≤ÈÅÆÁΩ©Â±ÇÔºåÂõ†‰∏∫Â∑≤ÁªèÊúâÈ©¨ËµõÂÖãÊïàÊûú‰∫Ü
                    this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                    return;
                }

                // Ê∏ÖÈô§‰πãÂâçÁöÑÂèØËßÜÂåñ
                this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);

                // ÁªòÂà∂ÊâÄÊúâÈÅÆÁΩ©Âå∫ÂüüÁöÑÂèØËßÜÂåñÔºà‰∏çÂΩ±ÂìçÁúüÂÆûÈÅÆÁΩ©Êï∞ÊçÆÔºâ
                this.maskCtx.globalCompositeOperation = 'source-over';
                this.maskCtx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // ÊµÖÈªëËâ≤Ôºå30%ÈÄèÊòéÂ∫¶

                this.maskRegions.forEach(region => {
                    this.maskCtx.beginPath();
                    this.maskCtx.arc(region.x, region.y, region.radius, 0, 2 * Math.PI);
                    this.maskCtx.fill();
                });
            }

            updatePreviewAtPosition(centerX, centerY, radius) {
                if (!this.isPreviewMode || !this.previewImageData) return;

                const startX = Math.max(0, Math.floor(centerX - radius));
                const startY = Math.max(0, Math.floor(centerY - radius));
                const endX = Math.min(this.displayWidth, Math.ceil(centerX + radius));
                const endY = Math.min(this.displayHeight, Math.ceil(centerY + radius));

                // ‰ΩøÁî®ÊòæÁ§∫ÂàÜËæ®ÁéáÁöÑÈ©¨ËµõÂÖãÂ§ßÂ∞è
                const displayMosaicSize = Math.max(1, Math.round(this.mosaicSize * this.displayScale));

                // ÊåâÈ©¨ËµõÂÖãÂùóÂ§ßÂ∞èÂ§ÑÁêÜÂå∫Âüü
                for (let y = startY; y < endY; y += displayMosaicSize) {
                    for (let x = startX; x < endX; x += displayMosaicSize) {
                        const blockCenterX = x + displayMosaicSize / 2;
                        const blockCenterY = y + displayMosaicSize / 2;
                        const distance = Math.sqrt(
                            Math.pow(blockCenterX - centerX, 2) +
                            Math.pow(blockCenterY - centerY, 2)
                        );

                        if (distance <= radius) {
                            this.applyMosaicToPreviewBlock(x, y, displayMosaicSize);
                        }
                    }
                }

                // Êõ¥Êñ∞ÁîªÂ∏ÉÊòæÁ§∫
                this.ctx.putImageData(this.previewImageData, 0, 0);
            }

            applyMosaicToPreviewBlock(startX, startY, blockSize) {
                let totalR = 0, totalG = 0, totalB = 0, count = 0;

                // ‰ªéÂΩìÂâçÂõæÁâáÊï∞ÊçÆËÆ°ÁÆóÂå∫ÂüüÂπ≥ÂùáÈ¢úËâ≤
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (Math.floor(y) * this.displayWidth + Math.floor(x)) * 4;
                        totalR += this.currentImageData.data[index];
                        totalG += this.currentImageData.data[index + 1];
                        totalB += this.currentImageData.data[index + 2];
                        count++;
                    }
                }

                if (count === 0) return;

                const avgR = Math.floor(totalR / count);
                const avgG = Math.floor(totalG / count);
                const avgB = Math.floor(totalB / count);

                // Â∫îÁî®Âà∞È¢ÑËßàÊï∞ÊçÆ
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (Math.floor(y) * this.displayWidth + Math.floor(x)) * 4;
                        this.previewImageData.data[index] = avgR;
                        this.previewImageData.data[index + 1] = avgG;
                        this.previewImageData.data[index + 2] = avgB;
                    }
                }
            }

            stopDrawing() {
                this.isDrawing = false;
                // ‰∏çÊ∏ÖÈô§ lastDrawPointÔºå‰øùÊåÅË∑ØÂæÑËøûÁª≠ÊÄßÁõ¥Âà∞‰∏ãÊ¨°ÂºÄÂßãÁªòÂà∂
            }

            applyMosaic() {
                if (!this.hasEdits) {
                    this.showStatus('Ê≤°ÊúâÊ∂ÇÊäπÂå∫ÂüüÈúÄË¶ÅÂ§ÑÁêÜ', 'info');
                    return;
                }

                // ÂàáÊç¢Âà∞È¢ÑËßàÊ®°Âºè
                this.isPreviewMode = true;
                this.canvasWrapper.classList.add('preview-active');

                this.showStatus('Ê≠£Âú®ÁîüÊàêÈ¢ÑËßàÊïàÊûú...', 'info');

                // ‰ΩøÁî® requestAnimationFrame Êù•ÈÅøÂÖçÈòªÂ°ûUI
                requestAnimationFrame(() => {
                    this.generatePreview();
                });
            }

            generatePreview() {
                // ÂàõÂª∫È¢ÑËßàÂõæÁâáÊï∞ÊçÆÁöÑÂâØÊú¨
                this.previewImageData = new ImageData(
                    new Uint8ClampedArray(this.currentImageData.data),
                    this.displayWidth,
                    this.displayHeight
                );

                // ÂàõÂª∫ÊòæÁ§∫ÂàÜËæ®ÁéáÁöÑÈÅÆÁΩ©Êï∞ÊçÆ
                const maskData = this.realMaskCtx.getImageData(0, 0, this.displayWidth, this.displayHeight);

                // Âú®È¢ÑËßàÊï∞ÊçÆ‰∏äÂ∫îÁî®È©¨ËµõÂÖã
                this.applyMosaicToPreview(this.previewImageData, maskData);

                // Êõ¥Êñ∞ÁîªÂ∏ÉÊòæÁ§∫
                this.ctx.putImageData(this.previewImageData, 0, 0);

                // Ê∏ÖÈô§ÂèØËßÜÂåñÈÅÆÁΩ©Â±ÇÔºàÂõ†‰∏∫Áé∞Âú®Áõ¥Êé•ÊòæÁ§∫È©¨ËµõÂÖãÊïàÊûúÔºâ
                this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);

                this.showStatus('È¢ÑËßàÊ®°ÂºèÂ∑≤ÂºÄÂêØÔºÅÊÇ®ÁúãÂà∞ÁöÑÂ∞±ÊòØÊúÄÁªà‰øùÂ≠òÊïàÊûú', 'success');

                // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
                this.setPreviewButtonState();
            }

            // Êñ∞Â¢ûÔºöËÆæÁΩÆÈ¢ÑËßàÊ®°Âºè‰∏ãÁöÑÊåâÈíÆÁä∂ÊÄÅ
            setPreviewButtonState() {
                const applyBtn = document.getElementById('applyBtn');
                applyBtn.textContent = 'üîÑ ÈÄÄÂá∫È¢ÑËßà';
                applyBtn.style.background = 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)';
            }

            applyMosaicToPreview(imageData, maskData) {
                const processedBlocks = new Set();
                const displayMosaicSize = Math.max(1, Math.round(this.mosaicSize * this.displayScale));

                for (let y = 0; y < this.displayHeight; y += displayMosaicSize) {
                    for (let x = 0; x < this.displayWidth; x += displayMosaicSize) {
                        const blockKey = `${x}_${y}`;
                        if (processedBlocks.has(blockKey)) continue;

                        // Ê£ÄÊü•Ëøô‰∏™ÂùóÊòØÂê¶Âú®ÈÅÆÁΩ©Âå∫ÂüüÂÜÖ
                        let shouldProcess = false;
                        for (let by = y; by < Math.min(y + displayMosaicSize, this.displayHeight) && !shouldProcess; by++) {
                            for (let bx = x; bx < Math.min(x + displayMosaicSize, this.displayWidth) && !shouldProcess; bx++) {
                                const maskIndex = (by * this.displayWidth + bx) * 4;
                                if (maskData.data[maskIndex] > 128) { // ÁôΩËâ≤Âå∫ÂüüË°®Á§∫ÈúÄË¶ÅÈ©¨ËµõÂÖã
                                    shouldProcess = true;
                                }
                            }
                        }

                        if (shouldProcess) {
                            this.applyMosaicToImageDataBlock(imageData, x, y, displayMosaicSize);
                            processedBlocks.add(blockKey);
                        }
                    }
                }
            }

            applyMosaicToImageDataBlock(imageData, startX, startY, blockSize) {
                let totalR = 0, totalG = 0, totalB = 0, count = 0;

                // ËÆ°ÁÆóÂå∫ÂüüÂπ≥ÂùáÈ¢úËâ≤
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (y * this.displayWidth + x) * 4;
                        totalR += this.currentImageData.data[index];
                        totalG += this.currentImageData.data[index + 1];
                        totalB += this.currentImageData.data[index + 2];
                        count++;
                    }
                }

                if (count === 0) return;

                const avgR = Math.floor(totalR / count);
                const avgG = Math.floor(totalG / count);
                const avgB = Math.floor(totalB / count);

                // Â∫îÁî®Âπ≥ÂùáÈ¢úËâ≤
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (y * this.displayWidth + x) * 4;
                        imageData.data[index] = avgR;
                        imageData.data[index + 1] = avgG;
                        imageData.data[index + 2] = avgB;
                    }
                }
            }

            exitPreview() {
                this.isPreviewMode = false;
                this.canvasWrapper.classList.remove('preview-active');

                // ÊÅ¢Â§çÂéüÂßãÊòæÁ§∫
                this.ctx.putImageData(this.currentImageData, 0, 0);

                // ÊÅ¢Â§çÈÅÆÁΩ©ÂèØËßÜÂåñ
                this.updateMaskVisualization();

                // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                this.resetApplyButtonState();

                this.showStatus('Â∑≤ÈÄÄÂá∫È¢ÑËßàÊ®°Âºè', 'info');
            }

            updatePreview() {
                if (!this.isPreviewMode) return;

                // ÈáçÊñ∞ÁîüÊàêÂÆåÊï¥È¢ÑËßà
                this.generatePreview();
            }

            clearMask() {
                this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                this.realMaskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                this.maskCache.clear();
                this.maskRegions = [];

                // Â¶ÇÊûúÂú®È¢ÑËßàÊ®°ÂºèÔºåÂÖàÈÄÄÂá∫
                if (this.isPreviewMode) {
                    this.exitPreview();
                }

                // ÊÅ¢Â§çÂéüÂßãÂõæÁâáÊòæÁ§∫
                this.ctx.drawImage(
                    this.originalImage,
                    0, 0, this.originalWidth, this.originalHeight,
                    0, 0, this.displayWidth, this.displayHeight
                );

                this.currentImageData = this.ctx.getImageData(0, 0, this.displayWidth, this.displayHeight);
                this.hasEdits = false;
                this.previewImageData = null;

                // ÈáçÁΩÆË∑ØÂæÑË∑üË∏™
                this.lastDrawPoint = null;

                this.showStatus('Ê∂ÇÊäπÂ∑≤Ê∏ÖÈô§ÔºåÂõæÁâáÂ∑≤ÊÅ¢Â§çÂéüÁä∂', 'success');
            }

            saveOriginalImage() {
                if (!this.originalFile) {
                    this.showStatus('ÂéüÂßãÊñá‰ª∂‰∏çÂèØÁî®', 'error');
                    return;
                }

                const link = document.createElement('a');
                const url = URL.createObjectURL(this.originalFile);

                link.download = this.hasEdits ?
                    this.originalFileName + '_original' + this.originalFileExtension :
                    this.originalFileName + this.originalFileExtension;
                link.href = url;
                link.click();

                setTimeout(() => URL.revokeObjectURL(url), 100);

                const fileSizeKB = Math.round(this.originalFile.size / 1024);
                this.showStatus(`ÂéüÂßãÂõæÁâáÂ∑≤‰øùÂ≠òÔºÅÊó†Ë¥®ÈáèÊçüÂ§±ÔºåÊñá‰ª∂Â§ßÂ∞è: ${fileSizeKB}KB`, 'success');
            }

            saveImage() {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                tempCanvas.width = this.originalWidth;
                tempCanvas.height = this.originalHeight;

                if (this.hasEdits) {
                    // ÊúâÁºñËæëÔºåÁîüÊàêÈ´òÂàÜËæ®ÁéáÈ©¨ËµõÂÖãÂõæÁâá
                    this.showStatus('Ê≠£Âú®ÁîüÊàêÈ´òÂàÜËæ®ÁéáÂõæÁâá...', 'info');
                    this.generateHighResolutionMosaic(tempCanvas, tempCtx);
                } else {
                    // Êó†ÁºñËæëÔºåÁõ¥Êé•ÁªòÂà∂ÂéüÂßãÂõæÁâá
                    tempCtx.drawImage(this.originalImage, 0, 0, this.originalWidth, this.originalHeight);
                    this.performSave(tempCanvas);
                }
            }

            generateHighResolutionMosaic(canvas, ctx) {
                // ÁªòÂà∂ÂéüÂßãÂõæÁâá
                ctx.drawImage(this.originalImage, 0, 0, this.originalWidth, this.originalHeight);
                const imageData = ctx.getImageData(0, 0, this.originalWidth, this.originalHeight);

                // ÂàõÂª∫ÂéüÂßãÂàÜËæ®ÁéáÁöÑÈÅÆÁΩ©
                const tempMaskCanvas = document.createElement('canvas');
                const tempMaskCtx = tempMaskCanvas.getContext('2d');
                tempMaskCanvas.width = this.originalWidth;
                tempMaskCanvas.height = this.originalHeight;

                // Â∞ÜÊòæÁ§∫ÂàÜËæ®ÁéáÁöÑÁúüÂÆûÈÅÆÁΩ©Áº©ÊîæÂà∞ÂéüÂßãÂàÜËæ®Áéá
                tempMaskCtx.drawImage(
                    this.realMaskCanvas,
                    0, 0, this.displayWidth, this.displayHeight,
                    0, 0, this.originalWidth, this.originalHeight
                );

                const maskData = tempMaskCtx.getImageData(0, 0, this.originalWidth, this.originalHeight);

                // Âú®ÂéüÂßãÂàÜËæ®Áéá‰∏äÂ∫îÁî®È©¨ËµõÂÖã
                this.applyHighResolutionMosaicToImageData(imageData, maskData);

                // Êõ¥Êñ∞ÁîªÂ∏É
                ctx.putImageData(imageData, 0, 0);

                // ‰øùÂ≠ò
                this.performSave(canvas);
            }

            applyHighResolutionMosaicToImageData(imageData, maskData) {
                const processedBlocks = new Set();

                for (let y = 0; y < this.originalHeight; y += this.mosaicSize) {
                    for (let x = 0; x < this.originalWidth; x += this.mosaicSize) {
                        const blockKey = `${x}_${y}`;
                        if (processedBlocks.has(blockKey)) continue;

                        // Ê£ÄÊü•Ëøô‰∏™ÂùóÊòØÂê¶Âú®ÈÅÆÁΩ©Âå∫ÂüüÂÜÖ
                        let shouldProcess = false;
                        for (let by = y; by < Math.min(y + this.mosaicSize, this.originalHeight) && !shouldProcess; by++) {
                            for (let bx = x; bx < Math.min(x + this.mosaicSize, this.originalWidth) && !shouldProcess; bx++) {
                                const maskIndex = (by * this.originalWidth + bx) * 4;
                                if (maskData.data[maskIndex] > 128) { // ÁôΩËâ≤Âå∫ÂüüË°®Á§∫ÈúÄË¶ÅÈ©¨ËµõÂÖã
                                    shouldProcess = true;
                                }
                            }
                        }

                        if (shouldProcess) {
                            this.applyHighResMosaicToBlock(imageData, x, y, this.mosaicSize);
                            processedBlocks.add(blockKey);
                        }
                    }
                }
            }

            applyHighResMosaicToBlock(imageData, startX, startY, blockSize) {
                let totalR = 0, totalG = 0, totalB = 0, count = 0;

                // ËÆ°ÁÆóÂå∫ÂüüÂπ≥ÂùáÈ¢úËâ≤
                for (let y = startY; y < Math.min(startY + blockSize, this.originalHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.originalWidth); x++) {
                        const index = (y * this.originalWidth + x) * 4;
                        totalR += imageData.data[index];
                        totalG += imageData.data[index + 1];
                        totalB += imageData.data[index + 2];
                        count++;
                    }
                }

                if (count === 0) return;

                const avgR = Math.floor(totalR / count);
                const avgG = Math.floor(totalG / count);
                const avgB = Math.floor(totalB / count);

                // Â∫îÁî®Âπ≥ÂùáÈ¢úËâ≤
                for (let y = startY; y < Math.min(startY + blockSize, this.originalHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.originalWidth); x++) {
                        const index = (y * this.originalWidth + x) * 4;
                        imageData.data[index] = avgR;
                        imageData.data[index + 1] = avgG;
                        imageData.data[index + 2] = avgB;
                    }
                }
            }

            performSave(canvas) {
                const link = document.createElement('a');

                // Ëé∑ÂèñÁî®Êà∑ÈÄâÊã©ÁöÑÊ†ºÂºè
                const selectedFormat = document.getElementById('outputFormat').value;

                let mimeType, fileExtension, qualityValue;

                switch (selectedFormat) {
                    case 'jpg':
                        mimeType = 'image/jpeg';
                        fileExtension = '.jpg';
                        qualityValue = this.quality / 100;
                        break;
                    case 'webp':
                        mimeType = 'image/webp';
                        fileExtension = '.webp';
                        qualityValue = this.quality / 100;
                        break;
                    case 'png':
                    default:
                        mimeType = 'image/png';
                        fileExtension = '.png';
                        qualityValue = 1; // PNG‰∏ç‰ΩøÁî®Ë¥®ÈáèÂèÇÊï∞
                        break;
                }

                const suffix = this.hasEdits ? '_mosaic' : '_copy';
                link.download = this.originalFileName + suffix + fileExtension;
                link.href = canvas.toDataURL(mimeType, qualityValue);
                link.click();

                const formatName = selectedFormat.toUpperCase();
                const statusMsg = this.hasEdits ?
                    `È©¨ËµõÂÖãÂõæÁâáÂ∑≤‰øùÂ≠ò‰∏∫${formatName}Ê†ºÂºèÔºÅÂéüÂßãÂàÜËæ®Áéá: ${this.originalWidth} √ó ${this.originalHeight}, Ë¥®Èáè: ${this.quality}%` :
                    `ÂõæÁâáÂâØÊú¨Â∑≤‰øùÂ≠ò‰∏∫${formatName}Ê†ºÂºèÔºÅÂàÜËæ®Áéá: ${this.originalWidth} √ó ${this.originalHeight}, Ë¥®Èáè: ${this.quality}%ÔºàÂª∫ËÆÆ‰ΩøÁî®"‰øùÂ≠òÂéüÂõæ"ÈÅøÂÖçË¥®ÈáèÊçüÂ§±Ôºâ`;

                this.showStatus(statusMsg, 'success');
            }
        }

        // ÂàùÂßãÂåñÂ∫îÁî®
        new MosaicEditor();
    </script>
</body>

</html>