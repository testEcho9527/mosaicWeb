<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡é©¬èµ›å…‹å¤„ç†å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .upload-btn {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }

        .slider {
            width: 180px;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            margin-bottom: 10px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .value-display {
            font-size: 1.1em;
            color: #667eea;
            font-weight: bold;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 30px 0;
            position: relative;
            gap: 20px;
        }

        .canvas-wrapper {
            position: relative;
            border: 3px solid #667eea;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-height: 600px;
            overflow: auto;
        }

        #canvas,
        #maskCanvas {
            display: block;
            transition: transform 0.2s ease;
        }

        #maskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.6;
            mix-blend-mode: multiply;
        }

        .drawing-mode #maskCanvas {
            pointer-events: auto;
            cursor: none;
        }

        .brush-cursor {
            position: fixed;
            border: 2px solid #667eea;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            background: rgba(102, 126, 234, 0.2);
            transform: translate(-50%, -50%);
            display: none;
            transition: all 0.1s ease;
        }

        .zoom-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .zoom-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .zoom-info {
            font-size: 0.9em;
            color: #667eea;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
        }

        .status {
            padding: 10px 20px;
            border-radius: 25px;
            margin: 10px 0;
            font-weight: bold;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status.error {
            background: rgba(244, 67, 54, 0.1);
            color: #F44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .status.info {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .dragging {
            cursor: grab !important;
        }

        .dragging:active {
            cursor: grabbing !important;
        }

        .image-info {
            text-align: center;
            color: #667eea;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .save-options {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .quality-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .performance-info {
            text-align: center;
            color: #667eea;
            font-size: 0.85em;
            margin-top: 5px;
            opacity: 0.8;
        }

        .preview-mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            display: none;
        }

        .format-selector select {
            padding: 8px 12px;
            border-radius: 15px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .format-selector select:hover {
            border-color: #764ba2;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .format-selector select:focus {
            outline: none;
            border-color: #764ba2;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .preview-active .preview-mode-indicator {
            display: block;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }

            .action-buttons {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 200px;
            }

            .canvas-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ å›¾ç‰‡é©¬èµ›å…‹å¤„ç†å™¨</h1>
            <p>ä¸Šä¼ å›¾ç‰‡ï¼Œæ¶‚æŠ¹åŒºåŸŸï¼Œå®æ—¶é¢„è§ˆé©¬èµ›å…‹æ•ˆæœ</p>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('imageInput').click()">
                    ğŸ“ é€‰æ‹©å›¾ç‰‡
                </button>
                <div id="status" class="status info" style="display: none;">è¯·é€‰æ‹©ä¸€å¼ å›¾ç‰‡å¼€å§‹å¤„ç†</div>
                <div id="imageInfo" class="image-info" style="display: none;"></div>
                <div id="performanceInfo" class="performance-info" style="display: none;"></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="brushSize">ç”»ç¬”å¤§å°</label>
                    <input type="range" id="brushSize" class="slider" min="1" max="50" value="20">
                    <span class="value-display" id="brushSizeValue">20px</span>
                </div>

                <div class="control-group">
                    <label for="pathSmoothness">è·¯å¾„å¹³æ»‘åº¦</label>
                    <input type="range" id="pathSmoothness" class="slider" min="1" max="10" value="3">
                    <span class="value-display" id="pathSmoothnessValue">ä¸­ç­‰</span>
                </div>

                <div class="control-group">
                    <label for="mosaicSize">é©¬èµ›å…‹ç²¾ç»†åº¦</label>
                    <input type="range" id="mosaicSize" class="slider" min="1" max="50" value="5">
                    <span class="value-display" id="mosaicSizeValue">5px</span>
                </div>

                <div class="control-group">
                    <label for="quality">ä¿å­˜è´¨é‡</label>
                    <input type="range" id="quality" class="slider" min="50" max="100" value="95">
                    <span class="value-display" id="qualityValue">95%</span>
                </div>

                <div class="action-buttons">
                    <div class="save-options">
                        <button class="btn" id="drawBtn" disabled>ğŸ–Œï¸ æ¶‚æŠ¹æ¨¡å¼</button>
                        <button class="btn" id="applyBtn" disabled>âœ¨ åº”ç”¨é©¬èµ›å…‹</button>
                        <button class="btn" id="clearBtn" disabled>ğŸ—‘ï¸ æ¸…é™¤æ¶‚æŠ¹</button>

                        <!-- åœ¨è¿™é‡Œæ·»åŠ æ ¼å¼é€‰æ‹©å™¨ -->
                        <div class="format-selector" style="display: flex; align-items: center; gap: 10px;">
                            <label for="outputFormat" style="color: #667eea; font-weight: bold;">ä¿å­˜æ ¼å¼:</label>
                            <select id="outputFormat"
                                style="padding: 8px; border-radius: 15px; border: 2px solid #667eea; background: white; color: #667eea; font-weight: bold;">
                                <option value="png">PNG (æ— æŸ)</option>
                                <option value="jpg">JPG (å‹ç¼©)</option>
                                <option value="webp">WebP (é«˜æ•ˆ)</option>
                            </select>
                        </div>

                        <button class="btn" id="saveBtn" disabled>ğŸ’¾ ä¿å­˜ç¼–è¾‘åçš„å›¾ç‰‡</button>
                        <button class="btn" id="saveOriginalBtn" disabled>ğŸ“¥ ä¿å­˜åŸå›¾</button>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="canvas"></canvas>
                    <canvas id="maskCanvas"></canvas>
                    <div class="brush-cursor" id="brushCursor"></div>
                    <div class="preview-mode-indicator">é¢„è§ˆæ¨¡å¼</div>
                </div>

                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomInBtn" disabled title="æ”¾å¤§">+</button>
                    <button class="zoom-btn" id="zoomOutBtn" disabled title="ç¼©å°">-</button>
                    <button class="zoom-btn" id="zoomResetBtn" disabled title="é‡ç½®ç¼©æ”¾">â†»</button>
                    <div class="zoom-info" id="zoomInfo">100%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class MosaicEditor {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.maskCanvas = document.getElementById('maskCanvas');
                this.maskCtx = this.maskCanvas.getContext('2d');
                this.canvasWrapper = document.getElementById('canvasWrapper');
                this.brushCursor = document.getElementById('brushCursor');

                // åŸå§‹å›¾ç‰‡æ•°æ®å’Œå°ºå¯¸
                this.originalImage = null;
                this.originalFile = null;
                this.originalWidth = 0;
                this.originalHeight = 0;
                this.originalImageData = null;
                this.currentImageData = null;
                this.hasEdits = false;

                // æ˜¾ç¤ºå°ºå¯¸å’Œç¼©æ”¾
                this.displayWidth = 0;
                this.displayHeight = 0;
                this.displayScale = 1;
                this.maxDisplaySize = 800; // æœ€å¤§æ˜¾ç¤ºå°ºå¯¸

                // é¢„è§ˆæ¨¡å¼ç›¸å…³
                this.isPreviewMode = false;
                this.previewImageData = null;

                // æ€§èƒ½ä¼˜åŒ–ç›¸å…³
                this.maskCache = new Map(); // ç¼“å­˜å·²å¤„ç†çš„é©¬èµ›å…‹å—
                this.throttleTimer = null;
                this.batchProcessing = false;
                this.pendingRegions = [];

                // åˆ†ç¦»çœŸå®é®ç½©æ•°æ®å’Œå¯è§†åŒ–
                this.maskRegions = []; // å­˜å‚¨çœŸå®çš„é®ç½©åŒºåŸŸæ•°æ®
                this.realMaskCanvas = document.createElement('canvas'); // çœŸå®çš„é®ç½©æ•°æ®
                this.realMaskCtx = this.realMaskCanvas.getContext('2d');

                this.isDrawing = false;
                this.drawingMode = false;

                // è·¯å¾„å¹³æ»‘ç›¸å…³
                this.lastDrawPoint = null; // ä¸Šä¸€ä¸ªç»˜åˆ¶ç‚¹
                this.pathSmoothness = 3; // è·¯å¾„å¹³æ»‘åº¦

                this.brushSize = 20;
                this.mosaicSize = 5;
                this.quality = 95;
                this.zoomLevel = 1;
                this.maxZoom = 3;
                this.minZoom = 0.25;

                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.scrollLeft = 0;
                this.scrollTop = 0;

                this.originalFileName = '';
                this.originalFileExtension = '';

                this.initEventListeners();
                this.updateBrushCursor();
                this.updateZoomDisplay();
            }

            initEventListeners() {
                // æ–‡ä»¶ä¸Šä¼ 
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });

                // æ§åˆ¶æ»‘å—
                const brushSizeSlider = document.getElementById('brushSize');
                const pathSmoothnessSlider = document.getElementById('pathSmoothness');
                const mosaicSizeSlider = document.getElementById('mosaicSize');
                const qualitySlider = document.getElementById('quality');

                brushSizeSlider.addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeValue').textContent = this.brushSize + 'px';
                    this.updateBrushCursor();
                });

                pathSmoothnessSlider.addEventListener('input', (e) => {
                    this.pathSmoothness = parseInt(e.target.value);
                    const smoothnessTexts = ['æœ€ä½', 'å¾ˆä½', 'è¾ƒä½', 'ä¸­ç­‰', 'è¾ƒé«˜', 'å¾ˆé«˜', 'æœ€é«˜', 'è¶…é«˜', 'æé«˜', 'å®Œç¾'];
                    document.getElementById('pathSmoothnessValue').textContent = smoothnessTexts[this.pathSmoothness - 1];
                });

                mosaicSizeSlider.addEventListener('input', (e) => {
                    this.mosaicSize = parseInt(e.target.value);
                    document.getElementById('mosaicSizeValue').textContent = this.mosaicSize + 'px';
                    // æ¸…é™¤ç¼“å­˜ï¼Œå› ä¸ºé©¬èµ›å…‹å¤§å°æ”¹å˜äº†
                    this.maskCache.clear();
                    // å¦‚æœåœ¨é¢„è§ˆæ¨¡å¼ï¼Œç«‹å³æ›´æ–°é¢„è§ˆ
                    if (this.isPreviewMode) {
                        this.updatePreview();
                    }
                });

                qualitySlider.addEventListener('input', (e) => {
                    this.quality = parseInt(e.target.value);
                    document.getElementById('qualityValue').textContent = this.quality + '%';
                });

                // æŒ‰é’®äº‹ä»¶ - ä¿®å¤è¿™é‡Œçš„äº‹ä»¶ç»‘å®š
                document.getElementById('drawBtn').addEventListener('click', () => this.toggleDrawingMode());
                document.getElementById('applyBtn').addEventListener('click', () => this.handleApplyButton());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearMask());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveImage());
                document.getElementById('saveOriginalBtn').addEventListener('click', () => this.saveOriginalImage());

                // ç¼©æ”¾æŒ‰é’®
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomResetBtn').addEventListener('click', () => this.resetZoom());

                // ç”»å¸ƒç»˜åˆ¶äº‹ä»¶
                this.maskCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.maskCanvas.addEventListener('mousemove', (e) => this.draw(e));
                this.maskCanvas.addEventListener('mouseup', () => this.stopDrawing());
                this.maskCanvas.addEventListener('mouseout', () => this.stopDrawing());
                this.maskCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
                this.maskCanvas.addEventListener('mousemove', (e) => this.updateCursorPosition(e));
                this.maskCanvas.addEventListener('mouseenter', () => this.showBrushCursor());
                this.maskCanvas.addEventListener('mouseleave', () => this.hideBrushCursor());

                // é¼ æ ‡æ»šè½®ç¼©æ”¾
                this.canvasWrapper.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (e.deltaY < 0) {
                        this.zoomIn();
                    } else {
                        this.zoomOut();
                    }
                });

                // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
                this.maskCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                    this.maskCanvas.dispatchEvent(mouseEvent);
                });

                this.maskCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.maskCanvas.dispatchEvent(mouseEvent);
                });

                this.maskCanvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const mouseEvent = new MouseEvent('mouseup', {});
                    this.maskCanvas.dispatchEvent(mouseEvent);
                });

                // é¼ æ ‡ä¸­é”®æ‹–æ‹½äº‹ä»¶
                this.canvasWrapper.addEventListener('mousedown', (e) => {
                    if (e.button === 1) {
                        e.preventDefault();
                        this.startDragging(e);
                    }
                });

                this.canvasWrapper.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        e.preventDefault();
                        this.drag(e);
                    }
                });

                this.canvasWrapper.addEventListener('mouseup', (e) => {
                    if (e.button === 1) {
                        this.stopDragging();
                    }
                });

                this.canvasWrapper.addEventListener('mouseleave', () => {
                    this.stopDragging();
                });
            }

            // æ–°å¢ï¼šç»Ÿä¸€å¤„ç†åº”ç”¨æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
            handleApplyButton() {
                if (this.isPreviewMode) {
                    this.exitPreview();
                } else {
                    this.applyMosaic();
                }
            }

            startDragging(e) {
                this.isDragging = true;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                this.scrollLeft = this.canvasWrapper.scrollLeft;
                this.scrollTop = this.canvasWrapper.scrollTop;
                this.canvasWrapper.classList.add('dragging');
            }

            drag(e) {
                if (!this.isDragging) return;

                const dx = e.clientX - this.dragStartX;
                const dy = e.clientY - this.dragStartY;

                this.canvasWrapper.scrollLeft = this.scrollLeft - dx;
                this.canvasWrapper.scrollTop = this.scrollTop - dy;
            }

            stopDragging() {
                this.isDragging = false;
                this.canvasWrapper.classList.remove('dragging');
            }

            showStatus(message, type = 'info') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
                statusEl.style.display = 'block';
            }

            // è®¡ç®—åˆé€‚çš„æ˜¾ç¤ºå°ºå¯¸
            calculateDisplaySize(originalWidth, originalHeight) {
                if (originalWidth <= this.maxDisplaySize && originalHeight <= this.maxDisplaySize) {
                    return {
                        width: originalWidth,
                        height: originalHeight,
                        scale: 1
                    };
                }

                const aspectRatio = originalWidth / originalHeight;
                let displayWidth, displayHeight;

                if (originalWidth > originalHeight) {
                    displayWidth = this.maxDisplaySize;
                    displayHeight = Math.round(this.maxDisplaySize / aspectRatio);
                } else {
                    displayHeight = this.maxDisplaySize;
                    displayWidth = Math.round(this.maxDisplaySize * aspectRatio);
                }

                return {
                    width: displayWidth,
                    height: displayHeight,
                    scale: displayWidth / originalWidth
                };
            }

            loadImage(file) {
                if (!file) return;

                this.originalFile = file;
                this.hasEdits = false;
                this.isPreviewMode = false;
                this.maskCache.clear();
                this.canvasWrapper.classList.remove('preview-active');

                this.originalFileName = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;
                this.originalFileExtension = file.name.substring(file.name.lastIndexOf('.')) || '.png';

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.originalWidth = img.width;
                        this.originalHeight = img.height;

                        // è®¡ç®—æ˜¾ç¤ºå°ºå¯¸
                        const displaySize = this.calculateDisplaySize(this.originalWidth, this.originalHeight);
                        this.displayWidth = displaySize.width;
                        this.displayHeight = displaySize.height;
                        this.displayScale = displaySize.scale;

                        // è®¾ç½®ç”»å¸ƒä¸ºæ˜¾ç¤ºå°ºå¯¸
                        this.canvas.width = this.displayWidth;
                        this.canvas.height = this.displayHeight;
                        this.maskCanvas.width = this.displayWidth;
                        this.maskCanvas.height = this.displayHeight;

                        // è®¾ç½®çœŸå®é®ç½©ç”»å¸ƒä¸ºæ˜¾ç¤ºå°ºå¯¸
                        this.realMaskCanvas.width = this.displayWidth;
                        this.realMaskCanvas.height = this.displayHeight;

                        // ç»˜åˆ¶ç¼©æ”¾åçš„å›¾ç‰‡åˆ°æ˜¾ç¤ºç”»å¸ƒ
                        this.ctx.drawImage(img, 0, 0, this.displayWidth, this.displayHeight);

                        // ä¿å­˜åŸå§‹å›¾ç‰‡æ•°æ®ï¼ˆåŸå§‹å°ºå¯¸ï¼‰
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = this.originalWidth;
                        tempCanvas.height = this.originalHeight;
                        tempCtx.drawImage(img, 0, 0, this.originalWidth, this.originalHeight);
                        this.originalImageData = tempCtx.getImageData(0, 0, this.originalWidth, this.originalHeight);

                        // ä¿å­˜å½“å‰æ˜¾ç¤ºçš„å›¾ç‰‡æ•°æ®
                        this.currentImageData = this.ctx.getImageData(0, 0, this.displayWidth, this.displayHeight);

                        // æ¸…é™¤é®ç½©å’Œé®ç½©åŒºåŸŸè®°å½•
                        this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                        this.realMaskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                        this.maskRegions = [];

                        // é‡ç½®è·¯å¾„è·Ÿè¸ª
                        this.lastDrawPoint = null;

                        this.zoomLevel = 1;
                        this.updateZoom();
                        this.enableButtons();
                        this.showImageInfo();

                        // é‡ç½®æŒ‰é’®çŠ¶æ€
                        this.resetApplyButtonState();

                        const isScaled = this.displayScale < 1;
                        const scaleInfo = isScaled ? `ï¼Œå·²ç¼©æ”¾è‡³ ${Math.round(this.displayScale * 100)}% æ˜¾ç¤º` : '';
                        this.showStatus(`å›¾ç‰‡åŠ è½½æˆåŠŸï¼${scaleInfo}æœªç¼–è¾‘æ—¶å»ºè®®ä½¿ç”¨"ä¿å­˜åŸå›¾"é¿å…è´¨é‡æŸå¤±`, 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            showImageInfo() {
                const infoEl = document.getElementById('imageInfo');
                const fileSizeKB = Math.round(this.originalFile.size / 1024);
                infoEl.textContent = `åŸå§‹åˆ†è¾¨ç‡: ${this.originalWidth} Ã— ${this.originalHeight}, æ–‡ä»¶å¤§å°: ${fileSizeKB}KB`;
                infoEl.style.display = 'block';

                const performanceInfoEl = document.getElementById('performanceInfo');
                if (this.displayScale < 1) {
                    performanceInfoEl.textContent = `ç¼–è¾‘åˆ†è¾¨ç‡: ${this.displayWidth} Ã— ${this.displayHeight} (${Math.round(this.displayScale * 100)}% ç¼©æ”¾ï¼Œä¼˜åŒ–æ€§èƒ½)`;
                    performanceInfoEl.style.display = 'block';
                } else {
                    performanceInfoEl.style.display = 'none';
                }
            }

            enableButtons() {
                ['drawBtn', 'clearBtn', 'saveBtn', 'saveOriginalBtn', 'zoomInBtn', 'zoomOutBtn', 'zoomResetBtn'].forEach(id => {
                    document.getElementById(id).disabled = false;
                });
            }

            // æ–°å¢ï¼šé‡ç½®åº”ç”¨æŒ‰é’®çŠ¶æ€
            resetApplyButtonState() {
                const applyBtn = document.getElementById('applyBtn');
                applyBtn.textContent = 'âœ¨ åº”ç”¨é©¬èµ›å…‹';
                applyBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }

            zoomIn() {
                if (this.zoomLevel < this.maxZoom) {
                    this.zoomLevel = Math.min(this.maxZoom, this.zoomLevel + 0.25);
                    this.updateZoom();
                }
            }

            zoomOut() {
                if (this.zoomLevel > this.minZoom) {
                    this.zoomLevel = Math.max(this.minZoom, this.zoomLevel - 0.25);
                    this.updateZoom();
                }
            }

            resetZoom() {
                this.zoomLevel = 1;
                this.updateZoom();
            }

            updateZoom() {
                this.canvas.style.transform = `scale(${this.zoomLevel})`;
                this.maskCanvas.style.transform = `scale(${this.zoomLevel})`;
                this.updateZoomDisplay();
                this.updateBrushCursor();
            }

            updateZoomDisplay() {
                document.getElementById('zoomInfo').textContent = Math.round(this.zoomLevel * 100) + '%';
                document.getElementById('zoomInBtn').disabled = this.zoomLevel >= this.maxZoom;
                document.getElementById('zoomOutBtn').disabled = this.zoomLevel <= this.minZoom;
            }

            toggleDrawingMode() {
                this.drawingMode = !this.drawingMode;
                const btn = document.getElementById('drawBtn');

                if (this.drawingMode) {
                    btn.textContent = 'ğŸ›‘ é€€å‡ºæ¶‚æŠ¹';
                    btn.style.background = 'linear-gradient(135deg, #f44336 0%, #d32f2f 100%)';
                    document.querySelector('.canvas-wrapper').classList.add('drawing-mode');
                    this.showStatus('æ¶‚æŠ¹æ¨¡å¼å·²å¼€å¯ï¼Œç°è‰²åŒºåŸŸè¡¨ç¤ºå·²æ¶‚æŠ¹èŒƒå›´', 'info');
                    document.getElementById('applyBtn').disabled = false;
                } else {
                    btn.textContent = 'ğŸ–Œï¸ æ¶‚æŠ¹æ¨¡å¼';
                    btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    document.querySelector('.canvas-wrapper').classList.remove('drawing-mode');
                    this.hideBrushCursor();
                    this.showStatus('æ¶‚æŠ¹æ¨¡å¼å·²å…³é—­', 'info');
                }

                // é‡ç½®è·¯å¾„è·Ÿè¸ª
                this.lastDrawPoint = null;
            }

            updateBrushCursor() {
                const scaledSize = this.brushSize * this.zoomLevel;
                this.brushCursor.style.width = scaledSize + 'px';
                this.brushCursor.style.height = scaledSize + 'px';
            }

            updateCursorPosition(e) {
                if (!this.drawingMode) return;
                this.brushCursor.style.left = e.clientX + 'px';
                this.brushCursor.style.top = e.clientY + 'px';
            }

            showBrushCursor() {
                if (this.drawingMode) {
                    this.brushCursor.style.display = 'block';
                }
            }

            hideBrushCursor() {
                this.brushCursor.style.display = 'none';
            }

            getMousePos(e) {
                const rect = this.maskCanvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            startDrawing(e) {
                if (!this.drawingMode) return;
                if (e.button !== 0) return;

                this.isDrawing = true;
                this.hasEdits = true;

                const pos = this.getMousePos(e);
                this.lastDrawPoint = pos;

                this.drawAtPosition(pos);
            }

            draw(e) {
                if (!this.isDrawing || !this.drawingMode) return;

                const currentPos = this.getMousePos(e);
                this.updateCursorPosition(e);

                if (this.lastDrawPoint) {
                    // ä½¿ç”¨è·¯å¾„å¹³æ»‘åº¦æ¥æ’å€¼ç»˜åˆ¶
                    this.drawSmoothPath(this.lastDrawPoint, currentPos);
                } else {
                    this.drawAtPosition(currentPos);
                }

                this.lastDrawPoint = currentPos;
            }

            // æ–°å¢ï¼šå¹³æ»‘è·¯å¾„ç»˜åˆ¶æ–¹æ³•
            drawSmoothPath(startPos, endPos) {
                const distance = Math.sqrt(
                    Math.pow(endPos.x - startPos.x, 2) +
                    Math.pow(endPos.y - startPos.y, 2)
                );

                // æ ¹æ®è·¯å¾„å¹³æ»‘åº¦å’Œç”»ç¬”å¤§å°è®¡ç®—æ’å€¼ç‚¹æ•°é‡
                // å¹³æ»‘åº¦è¶Šé«˜ï¼Œæ’å€¼ç‚¹è¶Šå¤šï¼Œè·¯å¾„è¶Šè¿ç»­
                const brushRadius = this.brushSize / 2;
                const maxStepSize = brushRadius / this.pathSmoothness;
                const steps = Math.max(1, Math.ceil(distance / maxStepSize));

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const interpolatedPos = {
                        x: startPos.x + (endPos.x - startPos.x) * t,
                        y: startPos.y + (endPos.y - startPos.y) * t
                    };

                    this.drawAtPosition(interpolatedPos);
                }
            }

            // æ–°å¢ï¼šåœ¨æŒ‡å®šä½ç½®ç»˜åˆ¶
            drawAtPosition(pos) {
                // è®°å½•é®ç½©åŒºåŸŸç”¨äºç”Ÿæˆæœ€ç»ˆé©¬èµ›å…‹
                this.maskRegions.push({
                    x: pos.x,
                    y: pos.y,
                    radius: this.brushSize / 2
                });

                // åœ¨çœŸå®é®ç½©ç”»å¸ƒä¸Šç»˜åˆ¶ï¼ˆç™½è‰²ï¼Œç”¨äºåç»­é©¬èµ›å…‹å¤„ç†ï¼‰
                this.realMaskCtx.globalCompositeOperation = 'source-over';
                this.realMaskCtx.fillStyle = 'white';
                this.realMaskCtx.beginPath();
                this.realMaskCtx.arc(pos.x, pos.y, this.brushSize / 2, 0, 2 * Math.PI);
                this.realMaskCtx.fill();

                // åœ¨å¯è§†åŒ–é®ç½©å±‚ç»˜åˆ¶å¯è§†åŒ–æç¤º
                this.updateMaskVisualization();

                // å¦‚æœåœ¨é¢„è§ˆæ¨¡å¼ï¼Œå®æ—¶æ›´æ–°é©¬èµ›å…‹æ•ˆæœ
                if (this.isPreviewMode) {
                    // èŠ‚æµå¤„ç†ï¼Œé¿å…é¢‘ç¹è®¡ç®—é©¬èµ›å…‹
                    if (this.throttleTimer) {
                        clearTimeout(this.throttleTimer);
                    }

                    this.throttleTimer = setTimeout(() => {
                        this.updatePreviewAtPosition(pos.x, pos.y, this.brushSize / 2);
                    }, 16); // çº¦60fps
                }
            }

            updateMaskVisualization() {
                if (this.isPreviewMode) {
                    // é¢„è§ˆæ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºç°è‰²é®ç½©å±‚ï¼Œå› ä¸ºå·²ç»æœ‰é©¬èµ›å…‹æ•ˆæœäº†
                    this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                    return;
                }

                // æ¸…é™¤ä¹‹å‰çš„å¯è§†åŒ–
                this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);

                // ç»˜åˆ¶æ‰€æœ‰é®ç½©åŒºåŸŸçš„å¯è§†åŒ–ï¼ˆä¸å½±å“çœŸå®é®ç½©æ•°æ®ï¼‰
                this.maskCtx.globalCompositeOperation = 'source-over';
                this.maskCtx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // æµ…é»‘è‰²ï¼Œ30%é€æ˜åº¦

                this.maskRegions.forEach(region => {
                    this.maskCtx.beginPath();
                    this.maskCtx.arc(region.x, region.y, region.radius, 0, 2 * Math.PI);
                    this.maskCtx.fill();
                });
            }

            updatePreviewAtPosition(centerX, centerY, radius) {
                if (!this.isPreviewMode || !this.previewImageData) return;

                const startX = Math.max(0, Math.floor(centerX - radius));
                const startY = Math.max(0, Math.floor(centerY - radius));
                const endX = Math.min(this.displayWidth, Math.ceil(centerX + radius));
                const endY = Math.min(this.displayHeight, Math.ceil(centerY + radius));

                // ä½¿ç”¨æ˜¾ç¤ºåˆ†è¾¨ç‡çš„é©¬èµ›å…‹å¤§å°
                const displayMosaicSize = Math.max(1, Math.round(this.mosaicSize * this.displayScale));

                // æŒ‰é©¬èµ›å…‹å—å¤§å°å¤„ç†åŒºåŸŸ
                for (let y = startY; y < endY; y += displayMosaicSize) {
                    for (let x = startX; x < endX; x += displayMosaicSize) {
                        const blockCenterX = x + displayMosaicSize / 2;
                        const blockCenterY = y + displayMosaicSize / 2;
                        const distance = Math.sqrt(
                            Math.pow(blockCenterX - centerX, 2) +
                            Math.pow(blockCenterY - centerY, 2)
                        );

                        if (distance <= radius) {
                            this.applyMosaicToPreviewBlock(x, y, displayMosaicSize);
                        }
                    }
                }

                // æ›´æ–°ç”»å¸ƒæ˜¾ç¤º
                this.ctx.putImageData(this.previewImageData, 0, 0);
            }

            applyMosaicToPreviewBlock(startX, startY, blockSize) {
                let totalR = 0, totalG = 0, totalB = 0, count = 0;

                // ä»å½“å‰å›¾ç‰‡æ•°æ®è®¡ç®—åŒºåŸŸå¹³å‡é¢œè‰²
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (Math.floor(y) * this.displayWidth + Math.floor(x)) * 4;
                        totalR += this.currentImageData.data[index];
                        totalG += this.currentImageData.data[index + 1];
                        totalB += this.currentImageData.data[index + 2];
                        count++;
                    }
                }

                if (count === 0) return;

                const avgR = Math.floor(totalR / count);
                const avgG = Math.floor(totalG / count);
                const avgB = Math.floor(totalB / count);

                // åº”ç”¨åˆ°é¢„è§ˆæ•°æ®
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (Math.floor(y) * this.displayWidth + Math.floor(x)) * 4;
                        this.previewImageData.data[index] = avgR;
                        this.previewImageData.data[index + 1] = avgG;
                        this.previewImageData.data[index + 2] = avgB;
                    }
                }
            }

            stopDrawing() {
                this.isDrawing = false;
                // ä¸æ¸…é™¤ lastDrawPointï¼Œä¿æŒè·¯å¾„è¿ç»­æ€§ç›´åˆ°ä¸‹æ¬¡å¼€å§‹ç»˜åˆ¶
            }

            applyMosaic() {
                if (!this.hasEdits) {
                    this.showStatus('æ²¡æœ‰æ¶‚æŠ¹åŒºåŸŸéœ€è¦å¤„ç†', 'info');
                    return;
                }

                // åˆ‡æ¢åˆ°é¢„è§ˆæ¨¡å¼
                this.isPreviewMode = true;
                this.canvasWrapper.classList.add('preview-active');

                this.showStatus('æ­£åœ¨ç”Ÿæˆé¢„è§ˆæ•ˆæœ...', 'info');

                // ä½¿ç”¨ requestAnimationFrame æ¥é¿å…é˜»å¡UI
                requestAnimationFrame(() => {
                    this.generatePreview();
                });
            }

            generatePreview() {
                // åˆ›å»ºé¢„è§ˆå›¾ç‰‡æ•°æ®çš„å‰¯æœ¬
                this.previewImageData = new ImageData(
                    new Uint8ClampedArray(this.currentImageData.data),
                    this.displayWidth,
                    this.displayHeight
                );

                // åˆ›å»ºæ˜¾ç¤ºåˆ†è¾¨ç‡çš„é®ç½©æ•°æ®
                const maskData = this.realMaskCtx.getImageData(0, 0, this.displayWidth, this.displayHeight);

                // åœ¨é¢„è§ˆæ•°æ®ä¸Šåº”ç”¨é©¬èµ›å…‹
                this.applyMosaicToPreview(this.previewImageData, maskData);

                // æ›´æ–°ç”»å¸ƒæ˜¾ç¤º
                this.ctx.putImageData(this.previewImageData, 0, 0);

                // æ¸…é™¤å¯è§†åŒ–é®ç½©å±‚ï¼ˆå› ä¸ºç°åœ¨ç›´æ¥æ˜¾ç¤ºé©¬èµ›å…‹æ•ˆæœï¼‰
                this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);

                this.showStatus('é¢„è§ˆæ¨¡å¼å·²å¼€å¯ï¼æ‚¨çœ‹åˆ°çš„å°±æ˜¯æœ€ç»ˆä¿å­˜æ•ˆæœ', 'success');

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                this.setPreviewButtonState();
            }

            // æ–°å¢ï¼šè®¾ç½®é¢„è§ˆæ¨¡å¼ä¸‹çš„æŒ‰é’®çŠ¶æ€
            setPreviewButtonState() {
                const applyBtn = document.getElementById('applyBtn');
                applyBtn.textContent = 'ğŸ”„ é€€å‡ºé¢„è§ˆ';
                applyBtn.style.background = 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)';
            }

            applyMosaicToPreview(imageData, maskData) {
                const processedBlocks = new Set();
                const displayMosaicSize = Math.max(1, Math.round(this.mosaicSize * this.displayScale));

                for (let y = 0; y < this.displayHeight; y += displayMosaicSize) {
                    for (let x = 0; x < this.displayWidth; x += displayMosaicSize) {
                        const blockKey = `${x}_${y}`;
                        if (processedBlocks.has(blockKey)) continue;

                        // æ£€æŸ¥è¿™ä¸ªå—æ˜¯å¦åœ¨é®ç½©åŒºåŸŸå†…
                        let shouldProcess = false;
                        for (let by = y; by < Math.min(y + displayMosaicSize, this.displayHeight) && !shouldProcess; by++) {
                            for (let bx = x; bx < Math.min(x + displayMosaicSize, this.displayWidth) && !shouldProcess; bx++) {
                                const maskIndex = (by * this.displayWidth + bx) * 4;
                                if (maskData.data[maskIndex] > 128) { // ç™½è‰²åŒºåŸŸè¡¨ç¤ºéœ€è¦é©¬èµ›å…‹
                                    shouldProcess = true;
                                }
                            }
                        }

                        if (shouldProcess) {
                            this.applyMosaicToImageDataBlock(imageData, x, y, displayMosaicSize);
                            processedBlocks.add(blockKey);
                        }
                    }
                }
            }

            applyMosaicToImageDataBlock(imageData, startX, startY, blockSize) {
                let totalR = 0, totalG = 0, totalB = 0, count = 0;

                // è®¡ç®—åŒºåŸŸå¹³å‡é¢œè‰²
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (y * this.displayWidth + x) * 4;
                        totalR += this.currentImageData.data[index];
                        totalG += this.currentImageData.data[index + 1];
                        totalB += this.currentImageData.data[index + 2];
                        count++;
                    }
                }

                if (count === 0) return;

                const avgR = Math.floor(totalR / count);
                const avgG = Math.floor(totalG / count);
                const avgB = Math.floor(totalB / count);

                // åº”ç”¨å¹³å‡é¢œè‰²
                for (let y = startY; y < Math.min(startY + blockSize, this.displayHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.displayWidth); x++) {
                        const index = (y * this.displayWidth + x) * 4;
                        imageData.data[index] = avgR;
                        imageData.data[index + 1] = avgG;
                        imageData.data[index + 2] = avgB;
                    }
                }
            }

            exitPreview() {
                this.isPreviewMode = false;
                this.canvasWrapper.classList.remove('preview-active');

                // æ¢å¤åŸå§‹æ˜¾ç¤º
                this.ctx.putImageData(this.currentImageData, 0, 0);

                // æ¢å¤é®ç½©å¯è§†åŒ–
                this.updateMaskVisualization();

                // æ¢å¤æŒ‰é’®çŠ¶æ€
                this.resetApplyButtonState();

                this.showStatus('å·²é€€å‡ºé¢„è§ˆæ¨¡å¼', 'info');
            }

            updatePreview() {
                if (!this.isPreviewMode) return;

                // é‡æ–°ç”Ÿæˆå®Œæ•´é¢„è§ˆ
                this.generatePreview();
            }

            clearMask() {
                this.maskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                this.realMaskCtx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                this.maskCache.clear();
                this.maskRegions = [];

                // å¦‚æœåœ¨é¢„è§ˆæ¨¡å¼ï¼Œå…ˆé€€å‡º
                if (this.isPreviewMode) {
                    this.exitPreview();
                }

                // æ¢å¤åŸå§‹å›¾ç‰‡æ˜¾ç¤º
                this.ctx.drawImage(
                    this.originalImage,
                    0, 0, this.originalWidth, this.originalHeight,
                    0, 0, this.displayWidth, this.displayHeight
                );

                this.currentImageData = this.ctx.getImageData(0, 0, this.displayWidth, this.displayHeight);
                this.hasEdits = false;
                this.previewImageData = null;

                // é‡ç½®è·¯å¾„è·Ÿè¸ª
                this.lastDrawPoint = null;

                this.showStatus('æ¶‚æŠ¹å·²æ¸…é™¤ï¼Œå›¾ç‰‡å·²æ¢å¤åŸçŠ¶', 'success');
            }

            saveOriginalImage() {
                if (!this.originalFile) {
                    this.showStatus('åŸå§‹æ–‡ä»¶ä¸å¯ç”¨', 'error');
                    return;
                }

                const link = document.createElement('a');
                const url = URL.createObjectURL(this.originalFile);

                link.download = this.hasEdits ?
                    this.originalFileName + '_original' + this.originalFileExtension :
                    this.originalFileName + this.originalFileExtension;
                link.href = url;
                link.click();

                setTimeout(() => URL.revokeObjectURL(url), 100);

                const fileSizeKB = Math.round(this.originalFile.size / 1024);
                this.showStatus(`åŸå§‹å›¾ç‰‡å·²ä¿å­˜ï¼æ— è´¨é‡æŸå¤±ï¼Œæ–‡ä»¶å¤§å°: ${fileSizeKB}KB`, 'success');
            }

            saveImage() {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                tempCanvas.width = this.originalWidth;
                tempCanvas.height = this.originalHeight;

                if (this.hasEdits) {
                    // æœ‰ç¼–è¾‘ï¼Œç”Ÿæˆé«˜åˆ†è¾¨ç‡é©¬èµ›å…‹å›¾ç‰‡
                    this.showStatus('æ­£åœ¨ç”Ÿæˆé«˜åˆ†è¾¨ç‡å›¾ç‰‡...', 'info');
                    this.generateHighResolutionMosaic(tempCanvas, tempCtx);
                } else {
                    // æ— ç¼–è¾‘ï¼Œç›´æ¥ç»˜åˆ¶åŸå§‹å›¾ç‰‡
                    tempCtx.drawImage(this.originalImage, 0, 0, this.originalWidth, this.originalHeight);
                    this.performSave(tempCanvas);
                }
            }

            generateHighResolutionMosaic(canvas, ctx) {
                // ç»˜åˆ¶åŸå§‹å›¾ç‰‡
                ctx.drawImage(this.originalImage, 0, 0, this.originalWidth, this.originalHeight);
                const imageData = ctx.getImageData(0, 0, this.originalWidth, this.originalHeight);

                // åˆ›å»ºåŸå§‹åˆ†è¾¨ç‡çš„é®ç½©
                const tempMaskCanvas = document.createElement('canvas');
                const tempMaskCtx = tempMaskCanvas.getContext('2d');
                tempMaskCanvas.width = this.originalWidth;
                tempMaskCanvas.height = this.originalHeight;

                // å°†æ˜¾ç¤ºåˆ†è¾¨ç‡çš„çœŸå®é®ç½©ç¼©æ”¾åˆ°åŸå§‹åˆ†è¾¨ç‡
                tempMaskCtx.drawImage(
                    this.realMaskCanvas,
                    0, 0, this.displayWidth, this.displayHeight,
                    0, 0, this.originalWidth, this.originalHeight
                );

                const maskData = tempMaskCtx.getImageData(0, 0, this.originalWidth, this.originalHeight);

                // åœ¨åŸå§‹åˆ†è¾¨ç‡ä¸Šåº”ç”¨é©¬èµ›å…‹
                this.applyHighResolutionMosaicToImageData(imageData, maskData);

                // æ›´æ–°ç”»å¸ƒ
                ctx.putImageData(imageData, 0, 0);

                // ä¿å­˜
                this.performSave(canvas);
            }

            applyHighResolutionMosaicToImageData(imageData, maskData) {
                const processedBlocks = new Set();

                for (let y = 0; y < this.originalHeight; y += this.mosaicSize) {
                    for (let x = 0; x < this.originalWidth; x += this.mosaicSize) {
                        const blockKey = `${x}_${y}`;
                        if (processedBlocks.has(blockKey)) continue;

                        // æ£€æŸ¥è¿™ä¸ªå—æ˜¯å¦åœ¨é®ç½©åŒºåŸŸå†…
                        let shouldProcess = false;
                        for (let by = y; by < Math.min(y + this.mosaicSize, this.originalHeight) && !shouldProcess; by++) {
                            for (let bx = x; bx < Math.min(x + this.mosaicSize, this.originalWidth) && !shouldProcess; bx++) {
                                const maskIndex = (by * this.originalWidth + bx) * 4;
                                if (maskData.data[maskIndex] > 128) { // ç™½è‰²åŒºåŸŸè¡¨ç¤ºéœ€è¦é©¬èµ›å…‹
                                    shouldProcess = true;
                                }
                            }
                        }

                        if (shouldProcess) {
                            this.applyHighResMosaicToBlock(imageData, x, y, this.mosaicSize);
                            processedBlocks.add(blockKey);
                        }
                    }
                }
            }

            applyHighResMosaicToBlock(imageData, startX, startY, blockSize) {
                let totalR = 0, totalG = 0, totalB = 0, count = 0;

                // è®¡ç®—åŒºåŸŸå¹³å‡é¢œè‰²
                for (let y = startY; y < Math.min(startY + blockSize, this.originalHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.originalWidth); x++) {
                        const index = (y * this.originalWidth + x) * 4;
                        totalR += imageData.data[index];
                        totalG += imageData.data[index + 1];
                        totalB += imageData.data[index + 2];
                        count++;
                    }
                }

                if (count === 0) return;

                const avgR = Math.floor(totalR / count);
                const avgG = Math.floor(totalG / count);
                const avgB = Math.floor(totalB / count);

                // åº”ç”¨å¹³å‡é¢œè‰²
                for (let y = startY; y < Math.min(startY + blockSize, this.originalHeight); y++) {
                    for (let x = startX; x < Math.min(startX + blockSize, this.originalWidth); x++) {
                        const index = (y * this.originalWidth + x) * 4;
                        imageData.data[index] = avgR;
                        imageData.data[index + 1] = avgG;
                        imageData.data[index + 2] = avgB;
                    }
                }
            }

            performSave(canvas) {
                const link = document.createElement('a');

                // è·å–ç”¨æˆ·é€‰æ‹©çš„æ ¼å¼
                const selectedFormat = document.getElementById('outputFormat').value;

                let mimeType, fileExtension, qualityValue;

                switch (selectedFormat) {
                    case 'jpg':
                        mimeType = 'image/jpeg';
                        fileExtension = '.jpg';
                        qualityValue = this.quality / 100;
                        break;
                    case 'webp':
                        mimeType = 'image/webp';
                        fileExtension = '.webp';
                        qualityValue = this.quality / 100;
                        break;
                    case 'png':
                    default:
                        mimeType = 'image/png';
                        fileExtension = '.png';
                        qualityValue = 1; // PNGä¸ä½¿ç”¨è´¨é‡å‚æ•°
                        break;
                }

                const suffix = this.hasEdits ? '_mosaic' : '_copy';
                link.download = this.originalFileName + suffix + fileExtension;
                link.href = canvas.toDataURL(mimeType, qualityValue);
                link.click();

                const formatName = selectedFormat.toUpperCase();
                const statusMsg = this.hasEdits ?
                    `é©¬èµ›å…‹å›¾ç‰‡å·²ä¿å­˜ä¸º${formatName}æ ¼å¼ï¼åŸå§‹åˆ†è¾¨ç‡: ${this.originalWidth} Ã— ${this.originalHeight}, è´¨é‡: ${this.quality}%` :
                    `å›¾ç‰‡å‰¯æœ¬å·²ä¿å­˜ä¸º${formatName}æ ¼å¼ï¼åˆ†è¾¨ç‡: ${this.originalWidth} Ã— ${this.originalHeight}, è´¨é‡: ${this.quality}%ï¼ˆå»ºè®®ä½¿ç”¨"ä¿å­˜åŸå›¾"é¿å…è´¨é‡æŸå¤±ï¼‰`;

                this.showStatus(statusMsg, 'success');
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        new MosaicEditor();
    </script>
</body>

</html>